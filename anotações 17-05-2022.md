Os 5 princípios da POO
S — Single Responsiblity Principle (Princípio da responsabilidade única)
O — Open-Closed Principle (Princípio Aberto-Fechado)
    Fazer o uso de classes abstratas, facilitando o processo de não deixar erros ao realizar uma alteração/manutenção. Padrões de projeto: Stragy, utiliza interfaces. Template utiliza classes abstratas. Se ao criar uma segunda classe você já criar uma interface, as modificações serão pequenas e fáceis. Pode se consierara que se o código for alterado uma vez, existe uma grande possibilidade de que ele precise ser alterado novamente. Se isso acontecer, o OCP te economizará tempo e esforço.

L — Liskov Substitution Principle (Princípio da substituição de Liskov)
    As classes filhas nunca devem quebrar as definições de tipo da classe pai/mãe. Caso utilizado heranças, devemos nós preocupar com esse princípio. Ou seja, o padrão de projeto Template deve ser usado nessas situações
    Uma subclasse deve sobrescrever (polimorfismo) os métodos da classe pai/mãe de uma maneira que não interrompa a funcionalidade do ponto de vista da classe que a utiliza (classe cliente)
    TIP: Dica, se você estiver lutando com que herdour da classe pai , você provavelmente feriu a LSP.

I — Interface Segregation Principle (Princípio da Segregação da Interface)
    Nenhum código cliente deve ser forçado a depende de métodos que não usa. As interfaces pertencem aos seus códigos clientes e não ás implmentações. Portanto, devemos sempre projetpa0las de forma a atender melhor aos códigos clientes. Algumas vezes podemos, outras vezes não podemos conhecer exatamente os códigos clientes. Mas quando pudermos, devemos quebrar nossas interfaces em muitas interfaces menores, para que atendam melhor ás necessidades exatas dos códigos clientes. Segregar em 3 interfaces especificas, pois a interface sendo utilizada por outras classes, as vezes os métodos da interface não faz sentido, e seria melhor estar diretamente na classe.
D — Dependency Inversion Principle (Princípio da inversão da dependência)
Módulos (classes na maioria das vezes) de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações. Módulos (classes na maioria das vezes) de alto nível não devem depender de módulos de baixo nível. Ambos devem depender de abstrações

Módulo de alto nível: qualquer um que depende de outro módulo.

Módulo de baixo nive: qualquer um que nao depende de outro módulo.
